var documenterSearchIndex = {"docs":
[{"location":"tutorials/getting_started/gap_decomposition/#Generalized-Assignment-Problem-with-Dantzig-Wolfe-Decomposition","page":"GAP Decomposition","title":"Generalized Assignment Problem with Dantzig-Wolfe Decomposition","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"This tutorial demonstrates how to use ReformulationKit to automatically reformulate a Generalized Assignment Problem (GAP) using Dantzig-Wolfe decomposition.","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#Problem-Description","page":"GAP Decomposition","title":"Problem Description","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"The Generalized Assignment Problem assigns jobs to machines with capacity constraints. Each assignment has a cost, and jobs can be penalized if not assigned.","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Mathematical formulation:","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"beginalign\nmin quad  sum_mj c_mj x_mj + sum_j p_j cdot textpenalty_j \ntextst quad  sum_m x_mj + textpenalty_j geq 1 quad forall j quad text(assignment) \n sum_j w_mj x_mj leq Q_m quad forall m quad text(capacity) \n x_mj in 01 quad textpenalty_j geq 0\nendalign","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#Setup-and-Data","page":"GAP Decomposition","title":"Setup and Data","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"using JuMP, ReformulationKit","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Problem dimensions and data","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"machines = 1:2\njobs = 1:3\nassignment_costs = [1 2 3; 4 5 6]  # Cost matrix: machines Ã— jobs\npenalty_costs = [10, 12, 8]        # Penalty for unassigned jobs\nweights = [1 1 1; 1 1 1]           # Resource consumption (uniform)\ncapacities = [2, 2]                # Machine capacities\n\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#JuMP-Model","page":"GAP Decomposition","title":"JuMP Model","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Create the complete GAP model:","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"model = Model()","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Variables","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"@variable(model, x[machines, jobs], Bin);    # Assignment variables\n@variable(model, penalty[jobs] >= 0);        # Penalty variables\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Constraints","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"@constraint(model, assignment[j in jobs],\n    sum(x[m, j] for m in machines) + penalty[j] >= 1);  # Each job assigned or penalized\n\n@constraint(model, knapsack[m in machines],\n    sum(weights[m, j] * x[m, j] for j in jobs) <= capacities[m]);  # Machine capacity\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Objective","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"@objective(model, Min,\n    sum(assignment_costs[m, j] * x[m, j] for m in machines, j in jobs) +\n    sum(penalty_costs[j] * penalty[j] for j in jobs));\n\nprintln(model)","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#Annotation-Function","page":"GAP Decomposition","title":"Annotation Function","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"The annotation function determines decomposition structure. It receives as argument the name first and then the indices of the variable or the constraint. You must annotate all constraints and variables.","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"gap_annotation(::Val{:x}, machine, job) = dantzig_wolfe_subproblem(machine)\ngap_annotation(::Val{:penalty}, job) = dantzig_wolfe_master()\ngap_annotation(::Val{:assignment}, job) = dantzig_wolfe_master()\ngap_annotation(::Val{:knapsack}, machine) = dantzig_wolfe_subproblem(machine)\n\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#Decomposition","page":"GAP Decomposition","title":"Decomposition","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Perform the automatic decomposition:","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"reformulation = dantzig_wolfe_decomposition(model, gap_annotation);\n\nprintln(master(reformulation))\n\nprintln(subproblems(reformulation)[1])","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/#Results-Analysis","page":"GAP Decomposition","title":"Results Analysis","text":"","category":"section"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Master Problem (coordinates job assignments):","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"master_problem = master(reformulation)\nprintln(master_problem)","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Subproblems (machine-specific decisions):","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"subproblems_dict = subproblems(reformulation);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"Each subproblem handles one machine's assignment decisions within capacity","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"for m in machines\n    sp = subproblems_dict[m]\n    println(\"-- subproblem for machine $m --\")\n    println(sp)\nend","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"","category":"page"},{"location":"tutorials/getting_started/gap_decomposition/","page":"GAP Decomposition","title":"GAP Decomposition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"ReformulationKit.jl requires Julia 1.6 or later and depends on the JuMP ecosystem for optimization modeling.","category":"page"},{"location":"installation/#Package-Installation","page":"Installation","title":"Package Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"ReformulationKit.jl is not yet registered in the Julia General Registry. Install it directly from the repository:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/nablarise/ReformulationKit.jl\")","category":"page"},{"location":"installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For development or to access the latest features:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.develop(url=\"https://github.com/nablarise/ReformulationKit.jl\")","category":"page"},{"location":"installation/#Quick-Verification","page":"Installation","title":"Quick Verification","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Test your installation with this simple example:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using JuMP, ReformulationKit\n\n# Create a simple model\nmodel = Model()\n@variable(model, x[1:2, 1:2], Bin)\n@constraint(model, coupling[j in 1:2], sum(x[i,j] for i in 1:2) >= 1)\n@constraint(model, local_constr[i in 1:2], sum(x[i,j] for j in 1:2) <= 1)\n@objective(model, Min, sum(x[i,j] for i in 1:2, j in 1:2))\n\n# Define annotation function\ntest_annotation(::Val{:x}, i, j) = dantzig_wolfe_subproblem(i)\ntest_annotation(::Val{:coupling}, j) = dantzig_wolfe_master()\ntest_annotation(::Val{:local_constr}, i) = dantzig_wolfe_subproblem(i)\n\n# Perform decomposition\nreformulation = dantzig_wolfe_decomposition(model, test_annotation)\n\n# Verify the result\nprintln(\"Installation successful! Reformulation type: $(typeof(reformulation))\")\nprintln(\"Master variables: $(num_variables(master(reformulation)))\")\nprintln(\"Subproblems: $(length(subproblems(reformulation)))\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If this runs without errors and prints the expected output, your installation is working correctly.","category":"page"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/#Common-Issues","page":"Installation","title":"Common Issues","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Package not found: Ensure you have an active internet connection and that Git is available on your system.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Dependency conflicts: Try updating your Julia packages:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update()","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia version: ReformulationKit requires Julia 1.6+. Check your version:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"versioninfo()","category":"page"},{"location":"installation/#Getting-Help","page":"Installation","title":"Getting Help","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you encounter installation issues:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Check the GitHub Issues for known problems\nCreate a new issue with your Julia version and error message\nJoin the Julia discourse for general Julia installation help","category":"page"},{"location":"installation/#Next-Steps","page":"Installation","title":"Next Steps","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Once installed, head to the GAP Tutorial to learn how to use ReformulationKit for decomposing optimization problems.","category":"page"},{"location":"#ReformulationKit.jl","page":"Home","title":"ReformulationKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReformulationKit automatically rewrites JuMP models into decomposed forms (e.g., Dantzig-Wolfe), based on simple annotations. It generates the master and subproblem models, letting you focus on modeling while it handles the reformulation logic.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modern optimization problems often benefit from decomposition techniques that exploit their structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReformulationKit makes decomposition easy through a simple annotation-based approach:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic reformulation: Transform your compact JuMP model with only additional code.\nStructure-aware: Leverages problem structure through user annotations  \nAlgorithm ready: Generates all necessary mappings for advanced algorithms\nJuMP integration: Works seamlessly with the Julia optimization ecosystem","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's how to decompose a Generalized Assignment Problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JuMP, ReformulationKit\n\n# Define annotation function\ngap_annotation(::Val{:x}, machine, job) = dantzig_wolfe_subproblem(machine)\ngap_annotation(::Val{:assignment}, job) = dantzig_wolfe_master()\ngap_annotation(::Val{:capacity}, machine) = dantzig_wolfe_subproblem(machine)\n\n# Create your JuMP model as usual\nmodel = Model()\n@variable(model, x[1:2, 1:3], Bin)\n@constraint(model, assignment[j in 1:3], sum(x[m,j] for m in 1:2) >= 1)\n@constraint(model, capacity[m in 1:2], sum(x[m,j] for j in 1:3) <= 2)\n@objective(model, Min, sum(x[m,j] for m in 1:2, j in 1:3))\n\n# Perform decomposition\nreformulation = dantzig_wolfe_decomposition(model, gap_annotation)\n\n# Access the results\nmaster = master(reformulation)           # Master problem with coupling constraints\nsubproblems = subproblems(reformulation) # Dict of subproblems by ID","category":"page"},{"location":"","page":"Home","title":"Home","text":"The decomposition automatically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Partitions variables between master and subproblems based on annotations\nCreates coupling constraints in the master for coordination\nGenerates capacity constraints in machine-specific subproblems\nSets up mappings for column generation algorithm","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ready to decompose your optimization problems? Start with our GAP Tutorial, which walks through a complete example of applying Dantzig-Wolfe decomposition to the Generalized Assignment Problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For installation instructions, see Installation.","category":"page"}]
}
